/*
 * Read an analogue value and send to the serial port (as a byte value)
 */



// PIC16F18344 Configuration Bit Settings

// 'C' source line config statements

// CONFIG1
#pragma config FEXTOSC = OFF    // FEXTOSC External Oscillator mode Selection bits (Oscillator not enabled)
#pragma config RSTOSC = HFINT32 // Power-up default value for COSC bits (HFINTOSC with 2x PLL (32MHz))
#pragma config CLKOUTEN = OFF   // Clock Out Enable bit (CLKOUT function is disabled; I/O or oscillator function on OSC2)
#pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is enabled)

// CONFIG2
#pragma config MCLRE = ON       // Master Clear Enable bit (MCLR/VPP pin function is MCLR; Weak pull-up enabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config WDTE = OFF       // Watchdog Timer Enable bits (WDT disabled; SWDTEN is ignored)
#pragma config LPBOREN = OFF    // Low-power BOR enable bit (ULPBOR disabled)
#pragma config BOREN = OFF      // Brown-out Reset Enable bits (Brown-out Reset disabled)
#pragma config BORV = LOW       // Brown-out Reset Voltage selection bit (Brown-out voltage (Vbor) set to 2.45V)
#pragma config PPS1WAY = ON     // PPSLOCK bit One-Way Set Enable bit (The PPSLOCK bit can be cleared and set only once; PPS registers remain locked after one clear/set cycle)
#pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable bit (Stack Overflow or Underflow will cause a Reset)
#pragma config DEBUG = OFF      // Debugger enable bit (Background debugger disabled)

// CONFIG3
#pragma config WRT = OFF        // User NVM self-write protection bits (Write protection off)
#pragma config LVP = ON         // Low Voltage Programming Enable bit (Low Voltage programming enabled. MCLR/VPP pin function is MCLR. MCLRE configuration bit is ignored.)

// CONFIG4
#pragma config CP = OFF         // User NVM Program Memory Code Protection bit (User NVM code protection disabled)
#pragma config CPD = OFF        // Data NVM Memory Code Protection bit (Data NVM code protection disabled)

#define _XTAL_FREQ 32000000

#include <xc.h>
#include <stdint.h>

void loop(void);

void main(void) {
    // Config settings based on code generated by MPLABX.

    // Oscillator config
    // NOSC HFINTOSC; NDIV 1; 
    OSCCON1 = 0x60;
    // CSWHOLD may proceed; SOSCPWR Low power; SOSCBE crystal oscillator; 
    OSCCON3 = 0x00;
    // LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
    OSCEN = 0x00;
    // HFFRQ 32_MHz; May not be needed if we set RSTOSC = HFINT32 above. 
    OSCFRQ = 0x07;

    // PORTC 0 & 1 inputs, everything else leave as output
    TRISC = 0x03;

    // ADC settings
    // ANSELx registers,  We are using 2 ADC channels: RC0, RC1
    ANSELC = 0x3;
    // ADGO stop; ADON enabled; CHS ANA0; 
    ADCON0 = 0x01;
    // ADFM left justified; ADNREF VSS; ADPREF VDD; ADCS FOSC/32; 
    ADCON1 = 0b00100000;
    // ADACT no_auto_trigger; 
    ADACT = 0x00;
    // Clear the result registers
    ADRESL = 0x00;
    ADRESH = 0x00;


    // Configure the EUSART
    RB7PPS = 0x14; // 0b00010100 RB7->EUSART:TX;    
    // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
    BAUD1CON = 0x08;
    // SPEN enabled; RX9 8-bit; CREN disabled; ADDEN disabled; SREN disabled; 
    RC1STA = 0x80;
    // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
    TX1STA = 0x24;
    // SP1BRGL 68; 
    SP1BRGL = 0x44;
    // SP1BRGH 0; 
    SP1BRGH = 0x00;

    loop();
}

void EUSART_Write(uint8_t txData) {
    while (0 == PIR1bits.TXIF) {
    }

    TX1REG = txData; // Write the data byte to the USART.
}

uint8_t ADC_pause = 0b00010000; // RC0 
uint8_t ADC_signal = 0b00010001; // RC1 
#define ACQ_US_DELAY 5

uint8_t ADC_GetConversion(uint8_t channel) {
    // select the A/D channel
    ADCON0bits.CHS = channel;
    // Acquisition time delay
    __delay_us(ACQ_US_DELAY);
    // Start the conversion
    ADCON0bits.ADGO = 1;
    // Wait for the conversion to finish
    while (ADCON0bits.ADGO){      
    }
    // Conversion finished, return the result (top 8 bits only)
    return ADRESH;
}

void loop(void) {
    uint16_t input_delay = 10;
    uint16_t pause = 10;

    while (1) {
        for (uint16_t p = pause; p > 0; p--){            
        }
        uint8_t result = ADC_GetConversion(ADC_signal);
        if (result > 250){
            result = 255; // saturation warning
        }
        EUSART_Write(result);
        // Every 100 samples, check the 'sampling rate' value
        if (input_delay-- == 0) {
            pause = ADC_GetConversion(ADC_pause);
            input_delay = 100;
        }
    }
}